name: CI Pipeline TypeScript

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    if: github.event.inputs.action != 'rollback' || github.event.inputs.action == null
    outputs:
      repo_name: ${{ steps.set_outputs.outputs.repo_name }}
      image_tag: ${{ steps.set_outputs.outputs.image_tag }}
    strategy:
      matrix:
        node-version: [20.x]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Necesario para SonarCloud

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'

      - name: Install dependencies
        run: |
          npm ci

      - name: Check code formatting with Prettier
        run: |
          npm run format:check

      - name: Run ESLint (Linter)
        run: |
          npm run lint || true

      - name: Build TypeScript
        run: |
          npm run build

      - name: Run Unit Tests with Jest and Coverage
        run: |
          npm run test:coverage -- --testPathIgnorePatterns=acceptance.test.ts

      - name: Setup Chrome for Selenium
        uses: browser-actions/setup-chrome@latest

      - name: Upload Test Reports Artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-reports
          path: |
            coverage/
            eslint-report.json

      - name: SonarCloud Scan
        uses: SonarSource/sonarqube-scan-action@v3.0.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: https://sonarcloud.io
      # --- Pasos de Docker (solo en push a main) ---

      - name: Set up QEMU
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Tag previous latest as rollback (before pushing new latest)
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          # Pull la imagen latest actual
          docker pull ${{ secrets.DOCKERHUB_USERNAME }}/${{ github.event.repository.name }}:latest || true
          
          # Si existe, re-etiquetarla como rollback
          if docker image inspect ${{ secrets.DOCKERHUB_USERNAME }}/${{ github.event.repository.name }}:latest &> /dev/null; then
            docker tag ${{ secrets.DOCKERHUB_USERNAME }}/${{ github.event.repository.name }}:latest \
                       ${{ secrets.DOCKERHUB_USERNAME }}/${{ github.event.repository.name }}:rollback
            docker push ${{ secrets.DOCKERHUB_USERNAME }}/${{ github.event.repository.name }}:rollback
            echo "Previous latest tagged as rollback"
          fi

      - name: Build and push Docker image
        id: docker_build_push # Darle ID para referenciar output
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/${{ github.event.repository.name }}:${{ github.sha }}
            ${{ secrets.DOCKERHUB_USERNAME }}/${{ github.event.repository.name }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
      
      # 13. Establecer las salidas del job usadas para el despliegue
      - name: Set Job Outputs
        id: set_outputs
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          echo "repo_name=${{ github.event.repository.name }}" >> $GITHUB_OUTPUT
          echo "image_tag=${{ github.sha }}" >> $GITHUB_OUTPUT



  # -------------------------------------
  # Job de Despliegue CloudFormation Staging
  # -------------------------------------
  deploy-cfn-staging:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: (github.event_name == 'push' && github.ref == 'refs/heads/main') && (github.event.inputs.action != 'rollback' || github.event.inputs.action == null)
    outputs:
      alb_url_staging: ${{ steps.get_stack_outputs.outputs.alb_url }}
      cluster_name_staging: ${{ steps.get_stack_outputs.outputs.cluster_name }}
      service_name_staging: ${{ steps.get_stack_outputs.outputs.service_name }}

    steps:
      # 1. Checkout del código (para acceder a template.yaml)
      - name: Checkout code
        uses: actions/checkout@v4

      # 2. Configurar credenciales de AWS (CON SESSION TOKEN)
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }} # <--- USO DEL SESSION TOKEN
          aws-region: us-east-1

      # 3. Desplegar/Actualizar el stack CloudFormation de Staging
      - name: Deploy CloudFormation Staging Stack
        run: |
          # Reconstruir la URI de la imagen usando el secreto y las salidas separadas
          IMAGE_URI="${{ secrets.DOCKERHUB_USERNAME }}/${{ needs.build-and-test.outputs.repo_name }}:${{ needs.build-and-test.outputs.image_tag }}"
          echo "Deploying Image URI: $IMAGE_URI" # Log para verificar (el username se ocultará aquí)

          aws cloudformation deploy \
            --template-file template.yaml \
            --stack-name calculadora-staging-stack \
            --parameter-overrides \
              EnvironmentName=staging \
              DockerImageUri=$IMAGE_URI \
              LabRoleArn=${{ secrets.LAB_ROLE_ARN }} \
              VpcId=${{ secrets.VPC_ID }} \
              SubnetIds="${{ secrets.SUBNET_IDS }}" \
            --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
            --no-fail-on-empty-changes # No falla si no hay cambios en la plantilla

      # 4. Obtener las salidas del Stack CloudFormation Staging
      - name: Get Staging Stack Outputs
        id: get_stack_outputs
        run: |
          # Instalar jq si no está presente (común en ubuntu-latest, pero por si acaso)
          if ! command -v jq &> /dev/null; then
             sudo apt-get update && sudo apt-get install -y jq
          fi

          STACK_OUTPUTS=$(aws cloudformation describe-stacks --stack-name calculadora-staging-stack --query "Stacks[0].Outputs" --region us-east-1 --output json)
          echo "Raw Stack Outputs: $STACK_OUTPUTS" # Log para depuración

          # Extraer la URL del ALB (ALBDnsName)
          ALB_URL=$(echo $STACK_OUTPUTS | jq -r '.[] | select(.OutputKey=="ALBDnsName") | .OutputValue')
          
          # Extraer el nombre del cluster ECS
          CLUSTER_NAME=$(echo $STACK_OUTPUTS | jq -r '.[] | select(.OutputKey=="ECSClusterName") | .OutputValue')
          
          # Extraer el nombre del servicio ECS  
          SERVICE_NAME=$(echo $STACK_OUTPUTS | jq -r '.[] | select(.OutputKey=="ECSServiceName") | .OutputValue')

          if [ -z "$ALB_URL" ] || [ "$ALB_URL" == "null" ]; then
            echo "Error: No se pudo obtener ALBDnsName del stack de Staging."
            exit 1
          fi
          
          if [ -z "$CLUSTER_NAME" ] || [ "$CLUSTER_NAME" == "null" ]; then
            echo "Error: No se pudo obtener ECSClusterName del stack de Staging."
            exit 1
          fi
          
          if [ -z "$SERVICE_NAME" ] || [ "$SERVICE_NAME" == "null" ]; then
            echo "Error: No se pudo obtener ECSServiceName del stack de Staging."
            exit 1
          fi

          # Añadir http:// al inicio ya que el DNSName no lo incluye
          ALB_URL_HTTP="http://${ALB_URL}/"
          echo "ALB URL Staging: $ALB_URL_HTTP"
          echo "Cluster Name Staging: $CLUSTER_NAME"
          echo "Service Name Staging: $SERVICE_NAME"
          
          echo "alb_url=${ALB_URL_HTTP}" >> $GITHUB_OUTPUT
          echo "cluster_name=${CLUSTER_NAME}" >> $GITHUB_OUTPUT
          echo "service_name=${SERVICE_NAME}" >> $GITHUB_OUTPUT

  # -------------------------------------
  # Job de Actualización Servicio Staging (ECS - Forzar despliegue)
  # -------------------------------------
  update-service-staging:
    # Depende de que CFN haya actualizado la Task Definition
    needs: [build-and-test, deploy-cfn-staging]
    runs-on: ubuntu-latest
    if: (github.event_name == 'push' && github.ref == 'refs/heads/main') && (github.event.inputs.action != 'rollback' || github.event.inputs.action == null)

    steps:
      # 1. Configurar credenciales de AWS (CON SESSION TOKEN)
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }} # <--- USO DEL SESSION TOKEN
          aws-region: us-east-1

      # 2. Forzar un nuevo despliegue en el servicio ECS de Staging
      - name: Force New Deployment ECS Service Staging
        run: |
          echo "Forcing new deployment for Staging service..."
          aws ecs update-service --cluster ${{ needs.deploy-cfn-staging.outputs.cluster_name_staging }} \
                                --service ${{ needs.deploy-cfn-staging.outputs.service_name_staging }} \
                                --force-new-deployment \
                                --region us-east-1
          # Esperar a que el despliegue se estabilice
          echo "Waiting for Staging service deployment to stabilize..."
          aws ecs wait services-stable --cluster ${{ needs.deploy-cfn-staging.outputs.cluster_name_staging }} --services ${{ needs.deploy-cfn-staging.outputs.service_name_staging }} --region us-east-1
          echo "Staging service deployment stable."

  # -------------------------------------
  # Job de Pruebas de Aceptación en Staging
  # -------------------------------------
  test-staging:
    needs: [update-service-staging, deploy-cfn-staging] # Depende de que el servicio esté estable con la nueva versión
    runs-on: ubuntu-latest
    if: (github.event_name == 'push' && github.ref == 'refs/heads/main') && (github.event.inputs.action != 'rollback' || github.event.inputs.action == null)
    strategy:
      matrix:
        node-version: [20.x]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Necesario para SonarCloud

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
      - name: Install dependencies
        run: |
          npm ci
      - name: Build TypeScript
        run: |
          npm run build
      

      # 4. Ejecutar pruebas de aceptación contra el entorno de Staging
      - name: Run Acceptance Tests against Staging
        env:
          APP_BASE_URL: ${{ needs.deploy-cfn-staging.outputs.alb_url_staging }}
        run: |
          echo "Running acceptance tests against: $APP_BASE_URL"
          # Ejecutar las pruebas de aceptación contra el entorno de Staging
          sleep 60
          npm run test:acceptance

  # -------------------------------------
  # Job de Despliegue CloudFormation Producción
  # -------------------------------------
  deploy-cfn-prod:
    needs: [build-and-test, test-staging] # Depende de la imagen y de que Staging esté OK
    runs-on: ubuntu-latest
    if: (github.event_name == 'push' && github.ref == 'refs/heads/main') && (github.event.inputs.action != 'rollback' || github.event.inputs.action == null)
    outputs: # Definir salida para la URL del ALB de producción
      alb_url_prod: ${{ steps.get_stack_outputs.outputs.alb_url }}
      cluster_name_prod: ${{ steps.get_stack_outputs.outputs.cluster_name }}
      service_name_prod: ${{ steps.get_stack_outputs.outputs.service_name }}

    steps:
      # 1. Checkout del código
      - name: Checkout code
        uses: actions/checkout@v4

      # 2. Configurar credenciales de AWS (CON SESSION TOKEN)
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }} # <--- USO DEL SESSION TOKEN
          aws-region: us-east-1

      # 3. Desplegar/Actualizar el stack CloudFormation de Producción
      - name: Deploy CloudFormation Production Stack
        run: |
          # Reconstruir la URI de la imagen usando el secreto y las salidas separadas
          IMAGE_URI="${{ secrets.DOCKERHUB_USERNAME }}/${{ needs.build-and-test.outputs.repo_name }}:${{ needs.build-and-test.outputs.image_tag }}"
          echo "Deploying Image URI: $IMAGE_URI" # Log para verificar

          aws cloudformation deploy \
            --template-file template.yaml \
            --stack-name calculadora-prod-stack \
            --parameter-overrides \
              EnvironmentName=production \
              DockerImageUri=$IMAGE_URI \
              LabRoleArn=${{ secrets.LAB_ROLE_ARN }} \
              VpcId=${{ secrets.VPC_ID }} \
              SubnetIds="${{ secrets.SUBNET_IDS }}" \
            --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
            --no-fail-on-empty-changes

      # 4. Obtener las salidas del Stack CloudFormation Producción
      - name: Get Production Stack Outputs
        id: get_stack_outputs
        run: |
          # Instalar jq si no está presente
          if ! command -v jq &> /dev/null; then
             sudo apt-get update && sudo apt-get install -y jq
          fi

          STACK_OUTPUTS=$(aws cloudformation describe-stacks --stack-name calculadora-prod-stack --query "Stacks[0].Outputs" --region us-east-1 --output json)
          echo "Raw Stack Outputs: $STACK_OUTPUTS" # Log

          # Extraer la URL del ALB (ALBDnsName)
          ALB_URL=$(echo $STACK_OUTPUTS | jq -r '.[] | select(.OutputKey=="ALBDnsName") | .OutputValue')
          
          # Extraer el nombre del cluster ECS
          CLUSTER_NAME=$(echo $STACK_OUTPUTS | jq -r '.[] | select(.OutputKey=="ECSClusterName") | .OutputValue')
          
          # Extraer el nombre del servicio ECS  
          SERVICE_NAME=$(echo $STACK_OUTPUTS | jq -r '.[] | select(.OutputKey=="ECSServiceName") | .OutputValue')

          if [ -z "$ALB_URL" ] || [ "$ALB_URL" == "null" ]; then
            echo "Error: No se pudo obtener ALBDnsName del stack de Producción."
            exit 1
          fi
          
          if [ -z "$CLUSTER_NAME" ] || [ "$CLUSTER_NAME" == "null" ]; then
            echo "Error: No se pudo obtener ECSClusterName del stack de Producción."
            exit 1
          fi
          
          if [ -z "$SERVICE_NAME" ] || [ "$SERVICE_NAME" == "null" ]; then
            echo "Error: No se pudo obtener ECSServiceName del stack de Producción."
            exit 1
          fi

          # Añadir http:// al inicio
          ALB_URL_HTTP="http://${ALB_URL}/"
          echo "ALB URL Production: $ALB_URL_HTTP"
          echo "Cluster Name Production: $CLUSTER_NAME"
          echo "Service Name Production: $SERVICE_NAME"
          
          echo "alb_url=${ALB_URL_HTTP}" >> $GITHUB_OUTPUT
          echo "cluster_name=${CLUSTER_NAME}" >> $GITHUB_OUTPUT
          echo "service_name=${SERVICE_NAME}" >> $GITHUB_OUTPUT

  # -------------------------------------
  # Job de Actualización Servicio Producción (ECS - Forzar despliegue)
  # -------------------------------------
  update-service-prod:
    needs: [build-and-test, deploy-cfn-prod] # Depende de que CFN haya actualizado la Task Def de Prod
    runs-on: ubuntu-latest
    if: (github.event_name == 'push' && github.ref == 'refs/heads/main') && (github.event.inputs.action != 'rollback' || github.event.inputs.action == null)

    steps:
      # 1. Configurar credenciales de AWS (CON SESSION TOKEN)
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }} # <--- USO DEL SESSION TOKEN
          aws-region: us-east-1

      # 2. Forzar un nuevo despliegue en el servicio ECS de Producción
      - name: Force New Deployment ECS Service Production
        run: |
          echo "Forcing new deployment for Production service..."
          aws ecs update-service --cluster ${{ needs.deploy-cfn-prod.outputs.cluster_name_prod }} \
                                --service ${{ needs.deploy-cfn-prod.outputs.service_name_prod }} \
                                --force-new-deployment \
                                --region us-east-1
          # Esperar a que el despliegue se estabilice
          echo "Waiting for Production service deployment to stabilize..."
          aws ecs wait services-stable --cluster ${{ needs.deploy-cfn-prod.outputs.cluster_name_prod }} --services ${{ needs.deploy-cfn-prod.outputs.service_name_prod }} --region us-east-1
          echo "Production service deployment stable."

  # -------------------------------------
  # Job de rollback (se ejecuta manualmente)
  rollback-production:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'  # Solo manual
    
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: us-east-1

      - name: Rollback to previous version
        run: |
          # Obtener la imagen de rollback
          ROLLBACK_IMAGE="${{ secrets.DOCKERHUB_USERNAME }}/${{ github.event.repository.name }}:rollback"
          
          # Actualizar task definition de producción con la imagen de rollback
          TASK_DEF=$(aws ecs describe-task-definition --task-definition calculadora-production-task --query 'taskDefinition' --output json)
          
          # Modificar la imagen en el task definition
          NEW_TASK_DEF=$(echo $TASK_DEF | jq --arg IMAGE "$ROLLBACK_IMAGE" '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)')
          
          # Registrar nueva task definition
          aws ecs register-task-definition --cli-input-json "$NEW_TASK_DEF"
          
          # Forzar despliegue del servicio
          aws ecs update-service --cluster calculadora-production-cluster \
                                --service calculadora-production-service \
                                --force-new-deployment
          
          # Esperar estabilidad
          aws ecs wait services-stable --cluster calculadora-production-cluster --services calculadora-production-service

      - name: Verify rollback
        run: |
          echo "Rollback completed. Service should now be running the previous version."